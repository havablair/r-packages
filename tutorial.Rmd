```{r preamble, echo=FALSE, results='hide', message=FALSE}

library(dplyr)
library(devtools)

knitr::opts_chunk$set(warning = FALSE,
                      error = FALSE)

```

# Packing up your data

## Motivation

An R package is the basic unit of reproducible code. There are lots of reasons you might want to make one:

1. As a "personal library" of functions that you use across lots of projects (by copying and pasting).
2. For ctual software that you want to share with others so they can use it, too (things like `lme4`).
3. To hold data from your experiments in a way that's easy to use, easy to share, and reproducibly tracks how the data was processed.

This guide focuses on the third use case. There are lots of good guides for the first case ([Hilary Parker's](https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/) is the classic), and if you're in the second camp you probably already know what you're doing (and if not, Hadley Wickham's [R packages book](http://r-pkgs.had.co.nz/) is an excellent and thorough guide).

We'll start from what used to be my default workflow (raw data file + R scripts to process and make figures etc.), and end up with an R package that allows you to both easily access pre-processed data and tracks how that data was generated from the raw form.


## Preliminaries

1. Install Rstudio.
2. Install `devtools`
3. Have some data you want to package, plus code to read it into R and process it into a useable form (in a `.R` or `.Rmd` file, etc.)

## What is a package?

To a first approximation, a minimal package is 

* a directory with 
* some R code in `R/` and 
* some metadata in `DESCRIPTION` (what the package is called, who made it, what it does, what other packages it depends on).

When you load a package with `library` or `require`, R looks in the package directory and runs the stuff`.R` files in `R/`.

## Packages can contain data

If there's a `data/` subdirectory in the package directory, R will also make any data files[^datafiles] there available. In R, the dataset has the same name as the data file. There are (at least) three ways to access data from a package:

### Using package namespace
```{r , }
ggplot2::diamonds %>% head()
```

### With `library()`

Then you can refer to datasets directly

```{r , }
library(ggplot2)
diamonds %>% head()
```
    
But they're not added to the global environment:
```{r , }
ls()
```

### With `data()`

This puts the requested dataset into the global environment:

```{r , }
data("diamonds", package="ggplot2")
ls()
```

You can also get a listing of all the datasets in a package with `data(package="ggplot2")`

[^datafiles]: Data files can be lots of things: `.RData`, `.csv`, `.R`, etc. See `?data`.

## How do I make a package

### Create the package skeleton

#### With RStudio (the easy way) ####

1. New Project -> New Directory -> R Package
2. Pick the name for your package (only letters, numbers, and `.`), and where it'll live locally (defaults to `~/`, your home directory). 
3. Check the "Create git repository" because why not.
2. Click on the `DESCRIPTION` file, and edit it.
3. Put your code files in the `R/` subdirectory.
4. Load the package ("Build" tab, More -> Load all; or ⌘-⇧-L)

#### With `devtools` (the slightly less easy way) ####

The `devtools` package is the back-end that RStudio uses to set up your package. It provides a convenient set of functions for doing those steps manually if you don't like clicking on buttons (or don't want to use RStudio):

1. Create the package skeleton with `devtools::create('~/mypackage')`.
2. Edit the information in `DESCRIPTION`.
3. Put your code in the `R/` subdirectory.

#### Manually (the dangerous, masochistic way) ####

You probably don't want to do this. These are the steps that `devtools` and RStudio automate for you.

1. Create [the `DESCRIPTION` file](http://r-pkgs.had.co.nz/description.html) in your package-to-be directory.
2. Create an `R/` subdirectory and put your code in there.

### Package workflow

The workflow when using a package is slightly different than you might be used to.

#### Local workflow

If you're just working within the package directory, the steps are simple:

1. Edit code (or add data).
2. Re-load packge with `devtools::load_all()` (or ⌘-⇧-L in RStudio)

#### Installed package workflow

If you're working from an _installed_ package (e.g. to use across multiple projects), when you edit the package code you need to build, install, and reload it:

1. Edit code (or add data).
2. Re-generate documentation and namespace: `devtools::document('/path/to/pkg')`
3. Install: `devtools::install('/path/to/pkg')`.
4. Reload: `devtools::reload(inst('pkg'))`.

Note that you only need to do this if you edit something in the _package_.

### Documentation and exports

By default, all the functions and variables that are created in your package are __private__ and not added to the global environment when you attach the package with `library()`. The `NAMESPACE` file tells R which things you want to export as part of the package's namespace. The easiest, best, and most foolproof way to generate this file is using special comments before each function/variable you want to export. For instance:

```{r , eval=FALSE}

#' Short description of what this does
#'
#' Longer description of what this does. Approximately a paragraph.
#'
#' @param x The first thing
#' @param y The second thing.
#' @return The thing that comes out of this function
#'
#' @export (do export this in NAMESPACE)
a_function <- function(x,y) {
  return x+y
}

```

Then, you run `devtools::document()`, which will update `NAMESPACE` and create help files in, e.g., `man/a_function.Rd`. And you can call `mypackage::a_function()` now, or just `a_function()` after `library(myfunction)`.

See the [R packages book on documentation](http://r-pkgs.had.co.nz/man.html) for more information on this. 

For our purposes, this isn't strictly necessary (if you're just doing `devtools::load_all()`, but it's important to know for later if you want to share this or `devtools::install()` your package.

## How do I put my data in the package

### Manually (bad)

1. Just move the data files (`.RData`, `.csv`, etc.) in the `data/` subdirectory of your package.

Bam, your data is in your package.

### Mostly manually, with `devtools` (bad)

1. Load the data into R, and do any processing you want.

    ```{r , eval=FALSE}
    experiment1 <- read.csv('expt1.csv') %>% mutate(experiment = 1)
    ```

2. Add the dataset to the package with

    ```{r , eval=FALSE}
    devtools::use_data(experiment1)
    ```

    This saves `data/experiment1.RData` in your package directory (make sure you've `setwd()` to the package directory...)

3. Now when you load the package, the dataset will be available as `experiment1`, already processed:

    ```{r , eval=FALSE}
    devtools::load_all()
    data("experiment1")
    ```

    As a freebie bonus, `.RData` files are much faster to read from disk than text-based formats like `.csv`. So every time you use this data, you're saving a little bit of time (or a lot of time if your data is more than a few hundred megabytes). This reduces the friction associated with re-compiling your `.Rmd` files (say), or creating new sessions/`.Rmd` files for each analysis, which in turn makes it way easier to make sure your analysis is really reproducible and self-contained.

4. You can save as many versions of the data as you'd like. For instance, if you want to have easy access to a sumamrized version of the dataset, you can save that, too:

    ```{r , eval=FALSE}
    experiment1_summary <- 
      experiment1 %>%
      group_by(subject, condition, block) %>%
      summarise(mean_rt = mean(rt))

    devtools::use_data(experiment1_summary)
    ```

### Reproducibly, with `devtools` (good)

So far, we've been mucking around in the console. This is bad for the same reason that it's bad to do all your data analysis directly in the console: there's no record of what you've done, and there's no reliable way to reproduce it once you close R.

The solution is the same: create a script that covers all the steps you took from beginning (loading that CSV) to end (`devtools::use_data()`). By including this script in your package along with the raw data, you get the convenience of having easy, fast access to the pre-processed data __and__ all the benefits of reproducibility.

Hadley (as usual) has thought of this, and `devtools` provides `devtools::use_data_raw()` which creates the `data-raw/` subdirectory and suggests the next steps you should take:

```{r eval=FALSE}
devtools::use_data_raw()
```
```
## Creating data-raw/
## Next: 
## * Add data creation scripts in data-raw
## * Use devtools::use_data() to add data to package
```
